---
title: "Multivariate Post-processing"
author: "Kate Saunders"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Multivariate Post-processing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(tidyverse)
library(lubridate)
library(knitr)
library(kableExtra)
```

## Introduction

### Ensemble Forecasting

What is ensemble forecasting:

* Intial conditions based on current weather observations
* Run the physcial model to forecast the future weather
* Climate is highly complex, so we can't observe the full distribution
* Instead we sampling different paths throughout the climate space to generate our forecasts
* These forecasts give us an idea of the distribution of the future weather
* Use these forecasts to make decisions
(Trajectory picture)


* Can then forecast if will it rain, or won't it rain (deterministic)
* More useful is given a distribution and including uncertainty (probabilistic)
* 70% chance it will rain, possible rainfall between 4 - 15 mm
* People can make better decisions with probabilistic forecasts
* For forecasting the key difference is deterministic vs probabilistic 

### Statistical Post-processing

<!-- * Post-processing is used to improve the forecasts because we don't know the true distribution -->
<!-- * Sample space is large, and we can't run simulations to cover the whole space -->
<!-- * Note, even if we could observe the full distribution, there will always be errors approximating the real world with a model  -->

* Climate models have errors
* Increasing the climate model resolution can decrease these errors
* However, the errors will always exist as the underyling model physics is an approximations to the true climate physics
(Nice to insert a figure of model approximations)
* We correct for these errors using statistics, this is what is known as statistical post-processing.

* Typically the first step in statistical post-processing is to correct the univariate marginal distributions. 
(Give crude example, showing bias and spread correction)

* The next step is to restore the dependence structure between related variables
* This package gives many of the basic methods for restoring dependence between variables in a post-processed ensemble forecasts

(Show the picture of mapping ie. similar to from Scheizfik '17)

## General Set Up

We propose the follow standard data format for ease of post-processing. This may vary slightly from application.

```{r echo = FALSE}
variable_labels = 
  c("FORECAST_DATE", "INIT_TIME", 
    "LEAD_TIME", "LOCATION", "ELEMENT", 
    "OBSERVATION", "ENS1", "ENS2", "ENS*")

variable_type = c("YMD", "HMS", 
                  "HMS", "String", "String",
                  "Numeric", "Numeric", "Numeric", "Numeric")

variable_description = 
  c("Date the forecast was issued", 
    "Time the forecast was initialised", 
    "Time until the forecast is observed",
    "Station name, or a coordinate reference",
    "Meteorlogical variable, for example TEMP or PRCP",
    "True Observation",
    "Forecast given by Ensemble Member 1",
    "Forecast given by Ensemble Member 2",
    "etc. Forecast given by Ensemble Member *")

variable_table = data.frame("Name" = variable_labels, 
                            "Description" = variable_description,
                            "Type" = variable_type)

kable(variable_table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

The third column is gives the varaible data type. Here `YMD` stands for year, month, day, and `HMS` stands for hour, minutes, seconds. 

When we score a forecast, the `FORECAST_DATE` and `INIT_TIME` are normally fixed variables. Other variables for space (`LOCATION`), time (`LEAD_TIME`) or intervariable (`ELEMENT`), all encode information about different types of dependence and are important for restoring dependence during multivariate post-processing. For some applications, one or more of these columns may have constant entries. For generality, we suggest including these standard variables and using this general format even if those variables are fixed.

### Quick comment on dates 

While base R caters for date types via `POSIXct()` and associated functions, the **lubridate** package offers broadly equaivalent functionality in a clearer and more concise way. The **lubridate** packge therefore offers a much easier way to process dates. It is therefore strongly suggested the columns of `FORECAST_DATE`, `INIT_TIME` and `LEAD_TIME` are converted into lubridate objects. 

```{r}
## Example converting different date strings to a date object
sample_dates = c("20200601", "2020-06-02", "2020/06/03")
lubridate_dates = lubridate::as_date(sample_dates)
print(lubridate_dates)

## Example creating an hms() object from an initialisation string
sample_init_times = c("0:0:0", "12:0:0")
lubridate_init_times = lubridate::hms(sample_init_times)
print(lubridate_init_times)

## Another example for hms() using an numeric input
sample_lead_times = c(0,6)
lubridate_lead_times = paste0(sample_lead_times, ":0:0") %>%
  lubridate::hms()
print(lubridate_lead_times)
```

For the columns of `INIT_TIME` and `LEAD_TIME` it is convienent to convert the `lubridate::hms()` objects into `lubridate::as.duration()`. This is for two reasons:

(i) Then the observation date can easily be obtained through the summation of `FORECAST_DATE`, `INIT_TIME` and `LEAD_TIME` if these variables are all date classes.

```{r}
lubridate_dates[1] + lubridate_init_times[2] + lubridate_lead_times[2]
```

(ii) The suite of join operations in the **dplyr** package can be used. Notice the difference between these these two join opertions in the following example. In the first example, the common entries are not correctly recognised. 

```{r}
## without lubridate::as.duration()
df1 <- df2 <- data.frame(
  INIT_TIME = lubridate_init_times, 
  LEAD_TIME = lubridate_lead_times)
dplyr::full_join(df1, df2, by = c("INIT_TIME", "LEAD_TIME"))

## with lubridate::as.duration()
df1 <- df2 <- data.frame(
  INIT_TIME = lubridate::as.duration(lubridate_init_times), 
  LEAD_TIME = lubridate::as.duration(lubridate_lead_times))
full_join(df1, df2, by = c("INIT_TIME", "LEAD_TIME"))
```

Using a duration for the columns of `INIT_TIME` and `LEAD_TIME` mostly gets around some sticky issues commonly encountered when using date objects. An exception is `bind_rows()`, which doesn't respect the duration class and instead reverts the entries to numeric types befor performing vector operations. An easy work around is to just convert the numeric types back into durations. 

```{r}
bind_rows(df1[1,], df1[2,]) 

# versus

bind_rows(df1[1,], df1[2,]) %>%
  dplyr::mutate(LEAD_TIME = lubridate::as.duration(LEAD_TIME),
                INIT_TIME = lubridate::as.duration(INIT_TIME))
```

When possible one could just use `rbind()` instead to avoid this issue. However,  `rbind()` won't work if the names of the two data frames are different and that is when `bind_rows()` may need to be called.

## Methods for restoring dependence

### Empirical Copula Coupling

### Schaake Shuffle 

#### Standard

#### Climatological 

#### Analogogs

#### Minimum Divergence

### Cannon - MbnR

### Optimal Assignment

<!-- What happens if I change something here  -->

<!-- Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format: -->

<!-- - Never uses retina figures -->
<!-- - Has a smaller default figure size -->
<!-- - Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style -->

<!-- ## Vignette Info -->

<!-- Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette. -->

<!-- ## Styles -->

<!-- The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows: -->

<!--     output:  -->
<!--       rmarkdown::html_vignette: -->
<!--         css: mystyles.css -->

<!-- ## Figures -->

<!-- The figure sizes have been customised so that you can easily put two images side-by-side.  -->

<!-- ```{r, fig.show='hold'} -->
<!-- plot(1:10) -->
<!-- plot(10:1) -->
<!-- ``` -->

<!-- You can enable figure captions by `fig_caption: yes` in YAML: -->

<!--     output: -->
<!--       rmarkdown::html_vignette: -->
<!--         fig_caption: yes -->

<!-- Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**. -->

<!-- ## More Examples -->

<!-- You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`. -->

<!-- ```{r, echo=FALSE, results='asis'} -->
<!-- knitr::kable(head(mtcars, 10)) -->
<!-- ``` -->

<!-- Also a quote using `>`: -->

<!-- > "He who gives up [code] safety for [code] speed deserves neither." -->
<!-- ([via](https://twitter.com/hadleywickham/status/504368538874703872)) -->
